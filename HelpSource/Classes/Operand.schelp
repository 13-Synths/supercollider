TITLE:: Operand
summary::Idempotent wrapper around math operations
categories:: Core
related:: Classes/AbstractFunction, Classes/Maybe, Classes/Ref, Classes/Rest

DESCRIPTION::
If you need to ensure that math operations always return the result wrapped in a specific object, you can use Operand or subclass from it.
For some practical examples, see its subclass link::Classes/Rest::.


Its creation is idempotent, that is code::Operand(Operand(x)) == Operand(x)::.


code::
// An Operand is and Operand is an Operand
Operand(Operand(Operand(1))) - 1
::

code::
// math operations
a = Operand(2);
b = Operand([1, 2, 3]);
c = a + b * a; // Operand([ 6, 8, 10 ])
c.value; // [ 6, 8, 10 ]
::

CLASSMETHODS::

METHOD:: new
argument:: value
Return a new instance of Operand, using an arbitrary object as value.


INSTANCEMETHODS::

METHOD:: value
Set or return the current value.

METHOD:: ==
argument:: obj
An Operand is equal to another one if their value are equal.
code::
Operand(1) == Operand(1);
Operand(1) + 2 == Operand(3);
::

METHOD:: dereferenceOperand
This method is called to avoid nesting. You may override it in subclasses to perform actions on resulting values.
code::Operand(Operand(1)) // Operand(1)::.


EXAMPLES::

code::
// you could make a class that always converts values to integers:

IntegerOperand : Operand {
	dereferenceOperand {
		^value.asInteger
	}
}

// then you would get:
IntegerOperand(1) + pi == IntegerOperand(4)
::



