title:: OSX_Standalones
summary:: Making simple standalones by copy-adapting existing apps.
categories:: Utilities

Note::
Known working versions for making standalones:
strong::SC3.8.0, SC3.9dev from branch [2a105f1]::
code::
"https://supercollider.github.io/download".openOS;
::
Self-built SC versions may have faulty userAppSupportDir behavior: sometimes code:: Platform.userAppSupportDir :: is code::.../SuperCollider/ :: and not the name of the newly made app.
::
written by Alberto de Campo, 2017

section:: Introduction

Guides/OSX_Standalones

What makes Standalone applications useful differs depending on their intended use. They can range from slightly diverging copies of a full SuperCollider.app with IDE and help system to an app tweaked specifically for a certain user group, with a custom interface, and little of standard SC3 still visible.


This Guide is for exporting copies of an existing SC3 setup,
for at least two scenarios:

A - Freezing an SC-based setup for non-expert users,
say an installation for a piece that runs in a museum,
which is as easily movable and selfcontained as possible.

B - Copying a setup for a piece or performance setup,as backup
or safety copy, keeping much flexibility for skilled users.

Creating more complex user-oriented applications with SC was possible in versions pre 3.6, and a number of people work on additions to SC that will allow similar flexibility again.


subsection:: How this guide works

This set of scripts creates a SuperCollider-based
Standalone app in a few basic steps:

1. copy the open SuperCollider.app or SC3-derived standalone.

2. fix the copy's info files so it uses its own userAppSupportDir

3. test that Platform.userAppSupportDir is independent in the new app!

Then the adaptation to the specific project begins:

4. transfer active quarks and extensions to the new app

5. copy the project folder used to the new app

6. make an internal startupFile for it

subsection:: What to prepare

* have your system ready with all desired quarks installed,
and a working startup file. (can be a very simple test setup)

* read each section, then try evaluating it at once;
 in case of problems, evaluate line by line,
 and tell me where which problems happen

* when you get to the wakeup kiss, share and enjoy!

subsection:: Naming, copying, and fixing up the new app

code::
// 0 - define name and location of new app + helper functions
(
// define the name for the new app and its location:
~newAppName = "Utopia_GenComp_39d";
~newAppLocation = "~/Desktop".standardizePath;

// some helper functions
~readText = { |path|
	var f = File(path, "r"); var t = f.readAllString; f.close; t;
};
~writeText = { |path, string| File(path, "w").write(string).close; };
~copyFolder = { |orig, dest|
	var str = "cp -r" + quote(orig) + quote(dest);
	str.postcs;
	unixCmd(str);
};

// make some needed paths and folders
~pathToThisApp = String.scDir.dirname.dirname;
~thisAppName = ~pathToThisApp.basename.splitext.first;
~pathToNewApp = ~newAppLocation +/+ ~newAppName ++ ".app";
~newAppResDir = ~pathToNewApp +/+ "Contents/Resources";
~newAppSupportDir = Platform.userConfigDir.replace(~thisAppName, ~newAppName);
);


(
// 1. make a copy of thisApp with the newAppName:
// can take a while on slow harddisks.
// wait for RESULT = 0 to show!

if (File.exists(~pathToNewApp).not) {
	~copyFolder.(~pathToThisApp, ~pathToNewApp);
	File.mkdir(~newAppSupportDir);
} { warn("% already exists.".format(~pathToNewApp)) };
);

(
// 2. fixups in the new app:
// a. fix the Info.plist file by replacing the name:
~infoPlistPath = ~pathToNewApp +/+ "Contents/Info.plist";
// get its string, replace the SC names, write again
~infoString = ~readText.(~infoPlistPath);

"replacing app name in plist file at these locations: ".post;
~infoString.findAll(~thisAppName).postln;

~newInfoString = ~infoString.replace(~thisAppName,  ~newAppName );
~writeText.(~infoPlistPath, ~newInfoString);
// ~readText.(~infoPlistPath);

// b. rename the binary file:
"renaming macos binary to: ".post;
// fixups in the new app - 2. rename the binary inside the app folder
unixCmd("mv" + quote(~pathToNewApp +/+ "Contents/MacOS/" +/+ ~thisAppName)
	+ quote(~pathToNewApp +/+ "Contents/MacOS/" ++ ~newAppName).postln);
);


// 3. *** time for the first wakeup kiss *** //
unixCmd("open" + ~pathToNewApp);

// ... and independence test!
// in the new app, run this code:
Platform.userAppSupportDir.postcs;

// >>>>> IF THIS HAS ~thisAppName (the one you started from,
// >>>>> e.g. SuperCollider) and NOT the ~newAppName:
// >>>>> delete it again, and use a different starting app!
/*
unixCmd("rm -r" + quote(~pathToNewApp));
*/
::

subsection:: Adaptation to the project

Quit the new standalone and go back to the starting app to do:

4. overwrite .startupFiles to look inside the app folder

5. make a demo project folder and loadfile for the new app

6.create a startup file that loads the project loadfile

7. transfer active quarks and extensions to the new app

8. replace/fill the project folder with your files, scripts etc


code::
(
// 4. write a class extension file to look for the startupFile
// in the app, in String.scDir for self-containment.
~overDir = ~newAppResDir +/+ "SCClassLibrary/SystemOverwrites";
File.mkdir(~overDir);
~writeText.value(~overDir +/+ "extModStartupFile.sc",
	"+ OSXPlatform {
	startupFiles {
		^[String.scDir +/+ \"startup.scd\"];
	}
}
"
);
~overDir.openOS;
)

// 5. make an example project folder,
// and a demo loadfile inside it:
(
~projDirName = ~newAppName ++ "_files";
~projDir = ~newAppResDir +/+ ~projDirName;
File.mkdir(~projDir);
~projDir.openOS;

~loadfilepath = ~projDir +/+ "00_loadMe.scd";
~writeText.value(~loadfilepath,
	"
\"*** startup file for % loading.\".postln;
\"*** My Platform.userAppSupportDir is: \".postln;
Platform.userAppSupportDir.postcs;
thisProcess.nowExecutingPath.openOS;

s.waitForBoot {
	\"*** server booted, plays ping.\".postln;
	Env.perc.test;

	\"*** loading files next ...\".postln;
	// put your loading sequence here:
	// \"loadX.scd\".loadRelative;
 	1.wait;
 	// \"loadY.scd\".loadRelative;
};"
.format(~newAppName)
);
~loadfilepath.openOS;
)

(
// 6. write a startupFile that points to the load file:
~startupCode =
"// example startup file for osx standalone.
// running loadfile in this project folder:
%.loadRelative;
".format((~projDirName +/+ ~loadfilepath.basename).cs);

~writeText.(~newAppResDir +/+ "startup.scd", ~startupCode);
(~newAppResDir +/+ "startup.scd").openOS;
)

// . *** time for the second wakeup kiss *** //
unixCmd("open" + ~pathToNewApp);

// this should open the new app, and its loadfile!


// 7. add the internal quarks folder:

(
// more polite and flexible, but needs configuration later:
// (add this folder as includePath, etc etc )
~newAppQuarksDir = ~newAppResDir +/+ "Z_AddedQuarks";

// so we do quick and dirty - just put them in SCClassLibrary.
// this works for classes are found directly, not for help files;
// ~newAppQuarksDir = ~newAppResDir +/+ "SCClassLibrary/Z_AddedQuarks";

// copy all folders in my current quarks includePaths
// to Resources/SCClassLibrary to freeze them:
File.mkdir(~newAppQuarksDir);

~quarkPaths = LanguageConfig.includePaths.reject { |path|
	["SCClassLibrary", "HelpSource"].includesEqual(path.basename)
};

~quarkPaths.collect(_.basename).sort.printcsAll;

if (~newAppQuarksDir.pathMatch.notEmpty) {
	"/*** copying Quarks : ***/".postln;
	~quarkPaths.do { |path|
		unixCmd(
			"cd" + quote(~newAppQuarksDir) ++ ";"
			" cp -r" + quote(path).postln + ".");
	};
};
"";
)
// open it to check
~newAppQuarksDir.openOS;


// add the ~quarks paths


// and now the new app should have all classes in quarks:
unixCmd("open" + ~pathToNewApp);

// IN THE NEW APP, run this:
LanguageConfig.addIncludePath(String.scDir +/+ "Z_AddedQuarks");
LanguageConfig.store;
// see if file is stored OK:
LanguageConfig.includePaths.last.pathMatch.postln;
// IN THE NEW APP, REBOOT THE INTERPRETER NOW!
// - the added quarks should now be present.


// 8. put your project files in the project folder,
// adapt the loading sequence,
// test test test etc etc etc

::
