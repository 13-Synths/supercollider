SuperCollider documentation system
==================================

INSTALLATION
------------
All SCDoc classes are in the subfolder "SCDoc", copy or symlink this folder to your SuperCollider Extensions folder.


USAGE
-----
To render and generate all docs:

SCDoc.helpSourceDir = "/path/to/HelpSource";
SCDoc.updateAll;

Now all your rendered HTML help is in SCDoc.helpTargetDir, which defaults to ~/share/SuperCollider/Help on Linux and ~/Application Support/SuperCollider/Help on OSX.

To render just one file:

SCDoc.helpSourceDir = "/path/to/HelpSource";
SCDoc.readDocMap;
SCDoc.updateFile("/path/to/HelpSource/and/your/file.schelp",true);

See these generated helpfiles for more info about ScDoc:

- Help/Reference/SCDocSyntax.html
- Help/Guides/WritingHelp.html
- Help/Classes/SCDoc.html
- Help/Classes/SCDocParser.html
- Help/Classes/SCDocRenderer.html


TODO
----

integration with frontends / main sc distro
===========================================
* HelpSource should be installed in thisProcess.platform.systemAppSupportDir

* ship pre-rendered help with the binary package (render after building supercollider)
just use the pre-rendered help until the users need to update help, which would first copy or hard-link the pre-rendered
files into helpTargetDir and then run SCDoc.updateAll. let SCDoc.helpClientDir return helpTargetDir if existent, else the system-wide location (thisProcess.platform.systemAppSupportDir +/+ "Help");

* Make updateAll return fast if nothing needs to be done:

Read a list of all classes so that we can detect if any new ones where added (extensions).
    old_classes = Object.readArchive(class_cache_path)
    current_classes = Class.allClasses.collectAs(_.name,IdentitySet)
    
Check each class in current_classes for update:
    if  class was not in old_classes (old_classes.includes(theClass.name).not) (means the class was newly installed)
    or: class source file is newer than the class_cache file (means the class source might have changed)
    then add it (and all its subclasses?) to new_classes (Set of classes that should be updated).

Traverse "HelpSource" folders to catch new and updated helpfiles:
    0) read docMap from archive, copy to old_docMap
    
    1) Use 'find' to get a list of HelpSource folders:
        a = [SCDoc.helpSourceDir];
        [thisProcess.platform.userExtensionDir, thisProcess.platform.systemExtensionDir].do {|dir|
            a = a ++ ("find -L"+dir.escapeChar($ )+"-name 'HelpSource' -type d")
                .unixCmdGetStdOut.split($\n).reject(_.isEmpty);
        };
        helpSourceDirs = a;
        
    2) Use 'find' to get a list of new and updated files:
        b = [];
        helpSourceDirs.do {|dir|
            b = b ++ ("find -L"+dir.escapeChar($ )+"-newer"+SCDoc.helpTargetDir.escapeChar($ )+/+"scdoc_cache -type f")
                .unixCmdGetStdOut.split($\n).reject(_.isEmpty);
        };
        
    3) Find new helpfolders:
       read old HelpSourceDirs from archive, if one was added since last time - go through every file in that dir and compare
       mtime to already rendered help - add to b.
       This catches newly installed extensions/quarks where the helpfile was not newer than scdoc_cache
       (is there a better solution for this?)
       
       Write new HelpSourceDirs to archive
        
    4) mark all docs in docMap for deletion
    
    5) Parse and render (.schelp) or copy (other) each file in b, set doc.delete = false.
       If file was a class, remove it from the new_classes Set.
    
    6) Use a "find dirs -iname '*.schelp'" for marking doc.delete = false
        helpSourceDirs.do {|dir|
            ("find -L"+dir.escapeChar($ )+"-name '*.schelp'").unixCmdGetStdOut.split($\n).reject(_.isEmpty).do {|f|
                var subtarget = f.copyRange(dir.size + 1, f.findBackwards(".") - 1);
                docMap[subtarget].delete = false;
            };
        };
       This catches any helpfile removals..
       
       NOTE: use folder mtime to see if there where any deleted files, so no need to find deleted
       files if no helpSourceDir was newer than scdoc_cache.. this will also trigger on added helpfiles but that's ok I guess:
       
        a = [];
        [SCDoc.helpSourceDir, thisProcess.platform.userExtensionDir, thisProcess.platform.systemExtensionDir].do {|dir|
            a = a ++ ("find -L"+dir.escapeChar($ )+"-name 'HelpSource' -type d -newer"+SCDoc.helpTargetDir.escapeChar($ )+/+"scdoc_cache")
                .unixCmdGetStdOut.split($\n).reject(_.isEmpty);
        };
        if(a.notEmpty) {this.findDeletedHelp};

    7) remove all docs from docMap with doc.delete == true an remove the 'delete' key.

For each class in new_classes Set, which now contains only undocumented *new* classes:
    - generate stub doc and render to HTML, add to docMap

If old_classes != current_classes:
    Write methods.js, class index overview and classtree page
    Write current_classes to file: current_classes.writeArchive(class_cache_path);

NOTE: or don't check for undocumented classes, but split this out to a separate SCDoc.makeUndocumentedClassDocs
that the user can run if he wants to? this method would just find all classes not present in docMap and generate&render the docs
and add them to docMap.

if old_docMap != docMap:
    Write docmap.js and scdoc_cache
else:
    touch scdoc_cache

* fix (adjust for SCDoc) or deprecate all old help classes and methods

-------------------------------------------

- make a SCDoc.makeClassTemplate(class,outputfile) that fills in the title, categories if existing, method and argument names, etc..

- this doesn't work as it should:

modalrangetag:: blah blah blah
blah blah blah blah blah
blah blah ::

- this doesn't work as it should:

hello

soft::there::

- tags after each other doesn't work, like returns::link::hello::
perhaps hard to fix without taking into account if the tag needs closing or not?
for example, what does this mean: code::foo::link::bar::

- using \::. doesn't work, needs a space: \:: .
also sometimes non-letters after :: doesn't work correctly, like "(link::hello::)"

- we need to distinguish between class and instance method anchors since some classes have both named the same,
something like #cmethod:name and #imethod:name perhaps? or #*classmethodname and #instancemethodname ?

- in methods overview, print '*' before classes implementing the method as classmethod?

- check for system-wide pre-rendered docs in ScDoc.findClassOrMethod and similar functions..
also make a ScDoc.findHelp(subdir,name,anchor) which would return the path to the helpfile. examples:
    ScDoc.findHelp("Classes","SinOsc")
    ScDoc.findHelp("Overviews","Methods","play")
    ScDoc.findHelp("","Search","^asString$"), etc...

- instead of showing "(extension)" only for classes, do it for any document that was located in an extension directory.
pass a flag to recurseHelpSource call in findExtHelp, and let updateFile return the doc map entry so we can set installed=\extension,
or pass the flag to updateFile and then to addToDocMap?
also add a check and warning for when a class file location and doc location is not the same in regards of extension or not?

- currently all auto-generated docs are not included in the docMap, we could add these manually to HelpSystem,
  or put them (and Help.html) in a tag named Help?
  add them to docmap *before* we generate the overviews that are using categories.

- description for categories? HelpSource/category_descriptions, example:
  Server>Abstractions: Client-side classes representing server-side stuff
  show in header and category browser/overview..
  extensions should be able to add such descriptions too, but not overwrite existing descriptions?

- handle formula:: tag. generate a hash hexstring for use as filename, HelpSource/formulas/xxxxxxxx.png
The renderer would render formula:: by displaying that image if it exists, if not and if LaTeX is installed, convert formula to image first. if LaTeX not installed and image don't exist, show the latex code. (use img alt text?) 

- comments (* like this? *)

- can setters have more than one arg? if so, we should fix rendering of setters.

- cross-platform: check all uses of systemCmd. move to Platform class?

- add argument:: for all args on methods even if the author didn't document it? at least check that argument names and order are correct.

- shortcuts for links to class:method? methodlink::Node#set:: renders as Node:set

- better error handling in parser on bogus input, etc..

- render binary op methods differently? like ArrayedCollections ++
we don't want it to display as "++ (aCollection)" do we? rather "++ aCollection" or "this ++ that" or something..
binary ops only uses chars from this list: !@%&*-+=|<>?/

- Handle methods added by extensions
Documenting added methods could be done in files named +ClassName.schelp
before we render each class, we need to find all +ClassName.schelp files and merge their parsed node tree with the current class.
We should probably find these files first and keep their full paths in a dictionary with classname as key.
note that they should *add* to classmethods and instancemethods instead of creating new sections for these..

- validation pass:

* Some tags should only be allowed once. like class, title, related, categories, summary, description, examples..
Also, they should only occur in the root node.

* private:: should come before any other method

* force class reference filename to be equal to class name

* check method argument names (and order?). it's ok to skip arguments though..

* make sure ## and || only happens inside lists/tables

