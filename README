New SC documentation system, work in progress
=============================================

The markup language parser is in ScDoc.sc, copy or symlink this to your Extensions folder.
Try it like this:

p = ScDocParser.new
p.parse("/home/lijon/Coding/ScDoc/test.sch")
p.dump

TODO
====

- Some tags should only be allowed once. like class, title, related, keywords, summary, description, methods, examples..
Keep a dictionary with tag occurence count?

- docType::, must be the first tag, so that it can control which tags are allowed?

- currently there's no support for nested tags. And is this really needed? If not, then we can have a single closing tag
for everything, like ::
If it is needed, we need to use a stack for this, or use the same stack as for structural tags??

- it would be nice if inline-tags didn't need whitespace.. link::Classes/SinOsc::
we could handle this for all tags by using a regex to extract the tag and the rest.. but then we need to handle the rest,
for example by calling handleWord recursively on it. another aproach would be to not scan the text by word but by character,
which would probably be too slow..

"link[[Classes/SinOsc]].".findRegexp("([a-z]+\\[\\[)(.+)(\\]\\])")[1..]

Or can we split words by whitespace and tags but include the tag symbol in the tags?
"See this link[[Classes/SinOsc]] yeah.".findRegexp("")

"See this link[[Classes/SinOsc]] yeah.".findRegexp("\\b[^ \n]+\\b").flop[1]

"See this link[[Classes/SinOsc]] yeah.".findRegexp("\\b[^ \n]+\\b|([a-z]+\\[\\[)(.+)(\\]\\])")
nah..

- differ between inline-tags like emphasis and block-style tags like table? inline tags comes inside normal prose,
while block tags are separate elements. currently normal prose are split into multiple elements at inline tags..
But this could be hard for the renderer to handle.. since we then need to take into account what kind of element we came
from and what element we are going to: don't put a <p> for a prose element that comes after an emphasis element that came inside a prose element. But, if we already know that an element is an inline-element, the renderer knows to "stay" in the current element type. This could of course also be done with the current tag:: ... ::tag syntax, by marking the element with an inline:true field
or something like that..

we could stick with code:: ... ::code but then we need to check if the tag starts a line (or something) to decide if it's
block or inline style. or perhaps better, to see if both opening and closing tag is on the same line?

all block-style tags should start the line.

- tables and lists are actually structural, but with closing tags.

- allow normal prose in tables and lists?

    (tag:'list::', children:[
        (tag:'##', text:"first item"),
        (tag:'##', text:"second item")
    ])

or as children elements:

    (tag:'list::', children:[
        (tag:'##', children:[
            (tag:'prose::', text:"first item")
        ]),
        (tag:'##', children:[
            (tag:'prose::', text:"second item")
        ])
    ])

or as a flat sequence:

    (tag:'list::', children:[
        (tag:'##'),
        (tag:'prose::', text:"first item"),
        (tag:'##'),
        (tag:'prose::', text:"second item")
    ])

We do want to allow inline-tags like link and emphasis inside lists and tables, so the last two alternatives might make more sense.
Perhaps the second is best? also have a row:: with children, or let first '##' in a line inside a table:: denote row?

- for code::, make sure everything is passed through as is, including whitespace. is this currently the case?

- infer 'introduction::' tag for prose before first section.

- split prose in multiple elements by blank lines in the parser, or handle them in the renderer?

- Missing tags
table::
row::
list::
numberedList::
##

- Grab introspection data for methods, arguments, class inheritance, etc..
should this be done in the parser, filled into the tree later, or added while rendering?

- Handle extensions (separate and method additions)

- HTML renderer.

