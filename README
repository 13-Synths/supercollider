New SC documentation system, work in progress
=============================================
Much more information can be read here: https://docs.google.com/document/edit?id=13jY-FLhwFYgzGFVTSb31eTZOsxl77eVLxuCIsXcZ7BE&hl=en&authkey=CJu58MQJ

The markup language parser is in ScDoc.sc, copy or symlink this to your Extensions folder.
Try it like this:

p = ScDocParser.new

p.parseFile("/home/lijon/Coding/ScDoc/HelpSource/Classes/Array.schelp")
p.renderHTML("/home/lijon/Coding/ScDoc/Help/Classes/Array.html")

p.parseFile("/home/lijon/Coding/ScDoc/HelpSource/Classes/LFPulse.schelp")
p.renderHTML("/home/lijon/Coding/ScDoc/Help/Classes/LFPulse.html")

p.parseFile("/home/lijon/Coding/ScDoc/HelpSource/Language/Literals.schelp")
p.renderHTML("/home/lijon/Coding/ScDoc/Help/Language/Literals.html")


p.parseFile("/home/lijon/Coding/ScDoc/test.schelp").dump
p.findNode("summary").text

p.parse("inline code::code example::.").dump
p.root

tag             hasText hasChilds structural needClose modal nestable
---------------------------------------------------------------------
title           S
class           S
doctype         S
keywords        S
related         S
summary         S
note            S
warning         S
section         S       x         1
subsection      S       x         2
classmethod     S       x         3
instancemethod  S       x         3
argument        S       x         4
description             x         1
methods                 x         1
examples                x         1
list                    x                    x               x
numberedlist            x                    x               x
definitionlist          x                    x               x
table                   x                    x               x
code            V                            x        x
link            V                            x        x
emphasis        V                            x        x
##
||
(prose)         V

hasText: tag captures text
    S is single-line (terminated by newline)
    V is variable-line
hasChilds: tag captures child-elements
structural: tag has structural level
needClose: tag needs closing by ::
modal: tag ignores any other tags than closing tag and do not nest
nestable: tag can nest

Note:
- modal tags can be written as inline: opening and closing tag on the same line
  or block-style: where the closing tag must be a single :: on its own line.
- single vs variable line is only applicable for tags that captures text.
- modal, level and nestable are exclusive. nestable can be seen as a structural tag
  without explicit level. It's also because of the explicit level that the structural
  tags don't need closing.
- structural-needClose-modal-nestable could be reduced to one column:
  1-4 : level, no close tag
  M   : modal, need close tag
  N   : nestable, need close tag

All in all we have 6 different categories of tags, not counting the internal 'prose' tag:
- hasTextS: line terminated simple tag, captures text
- hasTextS-hasChilds-structural: line terminated structural tag, captures text and children elements
- hasChilds-structural: unnamed structural tag, captures children elements
- hasChilds-needClose-nestable: nestable tag that needs closing, captures children elements
- hasTextV-needClose-modal: modal tag that needs closing, captures text
- delimiters: separator tag, does not capture anything

TODO
====
- handle categories::, should it output anything or is it just metadata?
move this to here from all UGens instead of using the categories class variable.
Also for all other classes?
Also for all other docs?

- anchor links? link::Classes/SinOsc#examples::
  should we have a tag to create anchors? anchor::name::

HTML renderer stuff:
- split into a separate class, then it's easy to make different renderers that conform to a common interface..
- handle docType (class/other), just run the whole tree for 'other' without forcing section orders, etc
- handle prose before first section in class doc?
- other sections not allowed in class doc?

- Overview generations:
  All documents alphabetically
  All documents by categories
  All documents by keywords (?)
  All classes by inheritance tree
  All classes alphabetically
  All classes by categories
  All undocumented classes
  All ugens alphabetically
  All ugens by categories
  All methods index
  
  should these generate ScDoc markup (probably not) or the native tree doc structure (probably yes)?
  
  for methods, the index is just an alphabetical list of links to Methods/methodname.html,
  which is a generated doc with a list of all classes implementing it (and the description of that method in that class?),
  if HelpSource/Methods/methodname.schelp exists, merge with this so can write interface style documentation?

- Code to traverse a directory tree of doc source files and render into another (user location) directory tree,
checking time-stamps to see if files need update or not. keep track of directory level so we can use relative URL's..

- generate simple doc for classes that don't have a doc source file. (just list all methods and their args)
put "this class currently lacks documentation" in description::

- Handle extensions (extra classes and method additions)
should merge stuff into the tree before parsing..? and mark method additions somehow so we can distinguish them visually in the rendered output.

- validation pass:
start by looking up the docType tag in the tree (root level), then we know which tags are allowed and not.

Some tags should only be allowed once. like class, title, related, keywords, summary, description, methods, examples..
Keep a dictionary with tag occurence count?

Also make sure ## and || only happens inside lists?

- parser: Don't split by lines but pass newlines to handleWord and let it call endLine for us? and inc lineno..
important: then we must check if the whitespace-word contains newline... (or create a regex rule that matches single newlines?)
also let handleWord inc wordno..
note: we could then also match blank lines by regex "\n\n*" and pass them to handleWord to split prose nodes.

