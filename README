New SC documentation system, work in progress
=============================================
Much more information can be read here: https://docs.google.com/document/edit?id=13jY-FLhwFYgzGFVTSb31eTZOsxl77eVLxuCIsXcZ7BE&hl=en&authkey=CJu58MQJ

The markup language parser is in ScDoc.sc, copy or symlink this to your Extensions folder.


Try it like this:

x = ScDoc.new;
x.helpSourceDir = "/home/lijon/Coding/ScDoc/HelpSource";
x.updateAll;

Now all your rendered HTML help is in x.helpTargetDir (default is ~/share/SuperCollider/Help on Linux)


The parses and renderer can be used individually:

p = ScDocParser.new
r = ScDocRenderer.new;

r.parser = p.parseFile("/home/lijon/Coding/ScDoc/HelpSource/Classes/Array.schelp")
r.renderHTML("/home/lijon/Coding/ScDoc/Help/Classes/Array.html")

r.parser = p.parseFile("/home/lijon/Coding/ScDoc/HelpSource/Classes/LFPulse.schelp")
r.renderHTML("/home/lijon/Coding/ScDoc/Help/Classes/LFPulse.html")

r.parser = p.parseFile("/home/lijon/Coding/ScDoc/HelpSource/Reference/Literals.schelp")
r.renderHTML("/home/lijon/Coding/ScDoc/Help/Reference/Literals.html")

r.parser = p.parseFile("/home/lijon/Coding/ScDoc/HelpSource/Help.schelp")
r.renderHTML("/home/lijon/share/SuperCollider/Help/Help.html")

p.parseFile("/home/lijon/Coding/ScDoc/test.schelp").dump
p.findNode("summary").text
p.parse("inline code::code example::.").dump
p.root
p.dump

tag             hasText hasChilds structural needClose modal nestable
---------------------------------------------------------------------
title           S
class           S
doctype         S
keywords        S
related         S
summary         S
note            S
warning         S
section         S       x         1
subsection      S       x         2
classmethod     S       x         3
instancemethod  S       x         3
argument        S       x         4
description             x         1
methods                 x         1
examples                x         1
list                    x                    x               x
tree                    x                    x               x
numberedlist            x                    x               x
definitionlist          x                    x               x
table                   x                    x               x
code            V                            x        x
link            V                            x        x
emphasis        V                            x        x
##
||
(prose)         V

hasText: tag captures text
    S is single-line (terminated by newline)
    V is variable-line
hasChilds: tag captures child-elements
structural: tag has structural level
needClose: tag needs closing by ::
modal: tag ignores any other tags than closing tag and do not nest
nestable: tag can nest

Note:
- modal tags can be written as inline: opening and closing tag on the same line
  or block-style: where the closing tag must be a single :: on its own line.
- single vs variable line is only applicable for tags that captures text.
- modal, level and nestable are exclusive. nestable can be seen as a structural tag
  without explicit level. It's also because of the explicit level that the structural
  tags don't need closing.
- structural-needClose-modal-nestable could be reduced to one column:
  1-4 : level, no close tag
  M   : modal, need close tag
  N   : nestable, need close tag

All in all we have 6 different categories of tags, not counting the internal 'prose' tag:
- hasTextS: line terminated simple tag, captures text
- hasTextS-hasChilds-structural: line terminated structural tag, captures text and children elements
- hasChilds-structural: unnamed structural tag, captures children elements
- hasChilds-needClose-nestable: nestable tag that needs closing, captures children elements
- hasTextV-needClose-modal: modal tag that needs closing, captures text
- delimiters: separator tag, does not capture anything

TODO
====
- better error handling in parser on bogus input, etc..

- handle binary/unary op methods somehow, like ArrayedCollections ++
we don't want it to display as "++ (aCollection)" do we?
one trick might be to detect if the method has no a-zA-Z and only one arg, and if so skip the parens..
Or, can we infer if a method is binary/unary op?
Also, getters/setters should perhaps be handled specially?

- It seems that if a paragraph ends with a closing :: (after a code or link tag for example), it is not split by the empty line following it. Adding any character after the last :: works around it, but this should be fixed..
Probably because \n is handled differently than other whitespace (this.endLine etc)..

- anchor links? link::Classes/SinOsc#examples::
  should we have a tag to create anchors? anchor::name::

HTML renderer stuff:
- handle prose before first section in class doc?
- other sections not allowed in class doc?

- Overview generations:
  All documents alphabetically
  All documents by categories
  DONE: All classes by inheritance tree
  All classes alphabetically
  All classes by categories
  All undocumented classes
  All ugens alphabetically
  All ugens by categories
  All methods index
  
  for methods, the index is just an alphabetical list of links to Methods/methodname.html,
  which is a generated doc with a list of all classes implementing it (and the description of that method in that class?),
  if HelpSource/Methods/methodname.schelp exists, merge with this so can write interface style documentation?

  to iterate over ugens, find all classes that implements ar, kr or ir.
  and/or use category 'UGen'?

- generate simple doc for classes that don't have a doc source file. (just list all methods and their args)
put "(this class currently lacks documentation)" in summary..
Simply scan through Class.allClasses and check if helpSourceDir +/+ "Classes" +/+ class.name++".schelp" exists.
we could even generate a code template for the class that can be copied from the generated doc and pasted to sourceFile.schelp..

- Handle extensions (extra classes and method additions)
should merge stuff into the tree before parsing..? and mark method additions somehow so we can distinguish them visually in the rendered output.

- validation pass:
start by looking up the docType tag in the tree (root level), then we know which tags are allowed and not.

Some tags should only be allowed once. like class, title, related, keywords, summary, description, methods, examples..
Keep a dictionary with tag occurence count?

Also make sure ## and || only happens inside lists?

- parser: Don't split by lines but pass newlines to handleWord and let it call endLine for us? and inc lineno..
important: then we must check if the whitespace-word contains newline... (or create a regex rule that matches single newlines?)
also let handleWord inc wordno..
note: we could then also match blank lines by regex "\n\n*" and pass them to handleWord to split prose nodes.

